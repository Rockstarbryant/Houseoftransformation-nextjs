Before we continue I would like you to follow my instructions.
1. My backend is using node.js my frontend is on Next.js framework.
2. I use superbase database for authentication only and MongoDB for roles and every other thing.
3. I use javascript in my files please DO NOT Write for me typescript files.
4. Strictly follow my instructions.
5. Be precise in your responces, this is to avoid hitting token limits and length limits too early before finishing the work.
6. Do not write unecessary files I have not asked for, always confirm with me before proceeding to write any file.
7. you are free to make suggestions but please you have to research on web if errors persist.
8. I will follow your guide keenly so if I tell you it did not work research for better solution rather than persisting on one thing or request for other files for reference.
9. If you think I have done anything wrong way maybe configured someothing the wrong way ask for a screenshot or my current file.
10. Lastly Before asking for a file confirm if I already sent you first, I do not want to send duplicate files.



{/* About Section */}
      <section className="py-12 md:py-20 border-b border-slate-50 dark:border-slate-300">
        <div className="max-w-full mx-auto px-4 md:px-8">
          <AboutSection preview />
        </div>
      </section>


rm -rf .next
rm -rf node_modules
npm install
npm run build

rm -rf .next
              
tree -L 3 -I 'node_modules'


npm cache clean --force
rm -rf .next node_modules
npm install
npm run build


 




              -- Create contributions table in Supabase
CREATE TABLE IF NOT EXISTS contributions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  campaign_id UUID NOT NULL REFERENCES campaigns(id) ON DELETE CASCADE,
  contributor_name TEXT NOT NULL,
  contributor_email TEXT,
  contributor_phone TEXT,
  amount DECIMAL(15, 2) NOT NULL CHECK (amount > 0),
  payment_method VARCHAR(50) NOT NULL DEFAULT 'mpesa',
  mpesa_ref TEXT,
  notes TEXT,
  is_anonymous BOOLEAN DEFAULT FALSE,
  status VARCHAR(50) DEFAULT 'pending',
  verified_by_id TEXT,
  verified_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_contributions_campaign ON contributions(campaign_id);
CREATE INDEX idx_contributions_status ON contributions(status);
CREATE INDEX idx_contributions_created ON contributions(created_at DESC);

-- RLS Policies
ALTER TABLE contributions ENABLE ROW LEVEL SECURITY;

-- Anyone can insert (for public contributions)
CREATE POLICY "allow_public_insert" ON contributions
  FOR INSERT WITH CHECK (true);

-- Users can view their own contributions
CREATE POLICY "users_view_own" ON contributions
  FOR SELECT USING (
    contributor_email = auth.jwt() ->> 'email' 
    OR auth.jwt() ->> 'role' = 'admin'
  );

-- Admins can view/update all
CREATE POLICY "admin_full_access" ON contributions
  FOR ALL USING (auth.jwt() ->> 'role' = 'admin');

-- Update updated_at on changes
CREATE OR REPLACE FUNCTION update_contributions_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_contributions_updated_at
BEFORE UPDATE ON contributions
FOR EACH ROW
EXECUTE FUNCTION update_contributions_updated_at();

-- Function to update campaign amount when contribution is verified
CREATE OR REPLACE FUNCTION update_campaign_from_contribution()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.status = 'verified' AND OLD.status != 'verified' THEN
    UPDATE campaigns
    SET current_amount = current_amount + NEW.amount
    WHERE id = NEW.campaign_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_campaign_from_contribution
AFTER UPDATE ON contributions
FOR EACH ROW
EXECUTE FUNCTION update_campaign_from_contribution();


-- ============================================
-- SUPABASE ADDITIONS FOR PAYMENT SECURITY
-- ============================================

-- ============================================
-- 1. IDEMPOTENCY KEYS TABLE (Prevent duplicate requests)
-- ============================================
CREATE TABLE IF NOT EXISTS idempotency_keys (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  idempotency_key UUID NOT NULL UNIQUE,
  user_id TEXT NOT NULL,
  endpoint TEXT NOT NULL,
  method VARCHAR(10) NOT NULL,
  response_status INTEGER NOT NULL,
  response_body JSONB NOT NULL,
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_idempotency_keys_user ON idempotency_keys(user_id);
CREATE INDEX idx_idempotency_keys_expires ON idempotency_keys(expires_at);

-- Auto-delete expired keys (optional, can use cron job instead)
-- CREATE TRIGGER cleanup_expired_idempotency_keys
-- AFTER INSERT ON idempotency_keys
-- FOR EACH ROW
-- EXECUTE FUNCTION cleanup_expired_keys();

-- ============================================
-- 2. CALLBACK LOGS TABLE (Prevent duplicate webhook processing)
-- ============================================
CREATE TABLE IF NOT EXISTS callback_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  callback_id TEXT UNIQUE NOT NULL,
  checkout_request_id TEXT NOT NULL,
  result_code VARCHAR(10),
  mpesa_receipt_number TEXT,
  raw_body JSONB NOT NULL,
  processing_status VARCHAR(50) NOT NULL DEFAULT 'processing',
  -- 'processing', 'completed', 'failed'
  error TEXT,
  processed_payment_id UUID REFERENCES payments(id) ON DELETE SET NULL,
  processed_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_callback_checkout_id ON callback_logs(checkout_request_id);
CREATE INDEX idx_callback_receipt ON callback_logs(mpesa_receipt_number);
CREATE INDEX idx_callback_status ON callback_logs(processing_status);
CREATE INDEX idx_callback_created ON callback_logs(created_at DESC);

-- ============================================
-- 3. ADD IDEMPOTENCY COLUMN TO PAYMENTS TABLE
-- ============================================
-- Run this if payments table exists:
ALTER TABLE payments ADD COLUMN IF NOT EXISTS idempotency_key UUID UNIQUE;
ALTER TABLE payments ADD COLUMN IF NOT EXISTS request_id TEXT;
ALTER TABLE payments ADD COLUMN IF NOT EXISTS processed_at TIMESTAMP WITH TIME ZONE;

CREATE INDEX IF NOT EXISTS idx_payments_idempotency ON payments(idempotency_key);
CREATE INDEX IF NOT EXISTS idx_payments_request_id ON payments(request_id);

-- ============================================
-- 4. UPDATE PAYMENTS TABLE CONSTRAINTS
-- ============================================

-- Add unique constraint to prevent duplicate M-Pesa receipts
CREATE UNIQUE INDEX IF NOT EXISTS idx_payments_mpesa_receipt_unique 
  ON payments(mpesa_receipt_number) 
  WHERE mpesa_receipt_number IS NOT NULL;

-- ============================================
-- 5. ADD COLUMNS TO CONTRIBUTIONS TABLE (if not exists)
-- ============================================
ALTER TABLE contributions ADD COLUMN IF NOT EXISTS idempotency_key UUID UNIQUE;
ALTER TABLE contributions ADD COLUMN IF NOT EXISTS callback_log_id UUID REFERENCES callback_logs(id);
ALTER TABLE contributions ADD COLUMN IF NOT EXISTS processing_status VARCHAR(50) DEFAULT 'pending';

CREATE INDEX IF NOT EXISTS idx_contributions_idempotency ON contributions(idempotency_key);

-- ============================================
-- 6. IMPROVED AUDIT TRIGGER FOR PAYMENTS
-- ============================================

-- Update pledge status: Set to 'completed' only when fully paid
CREATE OR REPLACE FUNCTION update_pledge_status()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.status = 'success' AND (OLD.status IS NULL OR OLD.status != 'success') THEN
    UPDATE pledges
    SET 
      paid_amount = paid_amount + NEW.amount,
      status = CASE 
        WHEN (paid_amount + NEW.amount) >= pledged_amount THEN 'completed'
        WHEN (paid_amount + NEW.amount) > 0 THEN 'partial'
        ELSE status
      END,
      updated_at = NOW()
    WHERE id = NEW.pledge_id
    -- âœ… Add safeguard: Only update if not already completed
    AND status != 'completed';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- 7. CAMPAIGN AMOUNT UPDATE WITH IDEMPOTENCY CHECK
-- ============================================

-- Prevent duplicate campaign updates
CREATE OR REPLACE FUNCTION update_campaign_amount()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.status = 'success' AND (OLD.status IS NULL OR OLD.status != 'success') THEN
    UPDATE campaigns
    SET 
      current_amount = current_amount + NEW.amount,
      updated_at = NOW()
    WHERE id = NEW.campaign_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- 8. RLS POLICIES FOR IDEMPOTENCY/CALLBACK TABLES
-- ============================================

ALTER TABLE idempotency_keys ENABLE ROW LEVEL SECURITY;
ALTER TABLE callback_logs ENABLE ROW LEVEL SECURITY;

-- Admins can view all
CREATE POLICY "admin_idempotency_view" ON idempotency_keys
  FOR SELECT USING (auth.jwt() ->> 'role' = 'admin');

CREATE POLICY "admin_callbacks_view" ON callback_logs
  FOR SELECT USING (auth.jwt() ->> 'role' = 'admin');

-- M-Pesa webhooks bypass RLS (service role)
-- No policy needed - service role ignores RLS

-- ============================================
-- 9. VERIFY CONTRIBUTIONS TABLE CONSTRAINTS
-- ============================================

-- Ensure amount is always positive
ALTER TABLE contributions ADD CONSTRAINT contributions_amount_positive 
  CHECK (amount > 0);

-- Ensure status is one of known values
ALTER TABLE contributions ADD CONSTRAINT contributions_status_check
  CHECK (status IN ('pending', 'verified', 'failed', 'cancelled'));

-- Prevent NULL payment method
ALTER TABLE contributions ADD CONSTRAINT contributions_payment_method_not_null
  CHECK (payment_method IS NOT NULL);

-- ============================================
-- 10. CREATE AUDIT VIEW
-- ============================================

CREATE OR REPLACE VIEW payment_audit_trail AS
SELECT 
  p.id,
  p.user_id,
  p.pledge_id,
  p.campaign_id,
  p.amount,
  p.payment_method,
  p.status,
  p.mpesa_receipt_number,
  p.verified_by_id,
  p.verified_at,
  p.created_at,
  p.processed_at,
  cl.callback_id,
  cl.result_code,
  cl.processing_status AS callback_status,
  ik.idempotency_key
FROM payments p
LEFT JOIN callback_logs cl ON cl.processed_payment_id = p.id
LEFT JOIN idempotency_keys ik ON ik.idempotency_key = p.idempotency_key
ORDER BY p.created_at DESC;

-- ============================================
-- 11. GRANT PERMISSIONS
-- ============================================

-- Allow service role to insert/update callback logs and idempotency keys
-- (Already have full access, but being explicit)




-- ============================================
-- SUPABASE DATABASE MIGRATIONS
-- Run these in your Supabase SQL Editor
-- ============================================

-- Migration 1: Add idempotency_key and user_id columns to contributions
-- ============================================
ALTER TABLE contributions 
ADD COLUMN IF NOT EXISTS idempotency_key TEXT,
ADD COLUMN IF NOT EXISTS user_id TEXT;

-- Add index for idempotency lookups
CREATE INDEX IF NOT EXISTS idx_contributions_idempotency 
ON contributions(idempotency_key, user_id);

-- Migration 2: Add columns for C2B transactions
-- ============================================
ALTER TABLE contributions 
ADD COLUMN IF NOT EXISTS transaction_id TEXT,
ADD COLUMN IF NOT EXISTS trans_time TIMESTAMP WITH TIME ZONE;

-- Migration 3: Add performance indexes
-- ============================================
CREATE INDEX IF NOT EXISTS idx_contributions_mpesa_ref 
ON contributions(mpesa_ref) 
WHERE mpesa_ref IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_contributions_phone 
ON contributions(contributor_phone) 
WHERE contributor_phone IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_contributions_campaign_date 
ON contributions(campaign_id, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_contributions_status_method 
ON contributions(status, payment_method);

-- Migration 4: Create idempotency_keys table (if using database instead of in-memory)
-- ============================================
CREATE TABLE IF NOT EXISTS idempotency_keys (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  idempotency_key TEXT NOT NULL,
  user_id TEXT NOT NULL,
  endpoint TEXT NOT NULL,
  method TEXT NOT NULL,
  response_status INTEGER NOT NULL,
  response_body JSONB NOT NULL,
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(idempotency_key, user_id)
);

-- Add index for cleanup
CREATE INDEX IF NOT EXISTS idx_idempotency_keys_expires 
ON idempotency_keys(expires_at);

-- Migration 5: Update RLS policies for contributions
-- ============================================

-- Drop existing policies (if any)
DROP POLICY IF EXISTS "allow_public_insert" ON contributions;
DROP POLICY IF EXISTS "users_view_own" ON contributions;
DROP POLICY IF EXISTS "admin_full_access" ON contributions;

-- Enable RLS
ALTER TABLE contributions ENABLE ROW LEVEL SECURITY;

-- Policy 1: Anyone can insert (for public contributions and M-Pesa callbacks)
CREATE POLICY "allow_public_insert" ON contributions
  FOR INSERT WITH CHECK (true);

-- Policy 2: Users can view their own contributions
CREATE POLICY "users_view_own" ON contributions
  FOR SELECT USING (
    user_id = (auth.jwt() ->> 'sub')
    OR contributor_email = (auth.jwt() ->> 'email')
    OR (auth.jwt() ->> 'role') = 'admin'
    OR (auth.jwt() ->> 'role') = 'service_role'
  );

-- Policy 3: Admins can do anything
CREATE POLICY "admin_full_access" ON contributions
  FOR ALL USING (
    (auth.jwt() ->> 'role') = 'admin'
    OR (auth.jwt() ->> 'role') = 'service_role'
  );

-- Migration 6: Add automatic status change trigger for verified contributions
-- ============================================

-- Function to update campaign amount when contribution is verified
CREATE OR REPLACE FUNCTION update_campaign_from_contribution()
RETURNS TRIGGER AS $$
BEGIN
  -- Only trigger on status change to 'verified'
  IF NEW.status = 'verified' AND (OLD.status IS NULL OR OLD.status != 'verified') THEN
    UPDATE campaigns
    SET 
      current_amount = current_amount + NEW.amount,
      updated_at = NOW()
    WHERE id = NEW.campaign_id;
  END IF;
  
  -- If status changed from 'verified' to something else, subtract
  IF OLD.status = 'verified' AND NEW.status != 'verified' THEN
    UPDATE campaigns
    SET 
      current_amount = GREATEST(0, current_amount - NEW.amount),
      updated_at = NOW()
    WHERE id = NEW.campaign_id;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger
DROP TRIGGER IF EXISTS trigger_update_campaign_from_contribution ON contributions;
CREATE TRIGGER trigger_update_campaign_from_contribution
  AFTER INSERT OR UPDATE ON contributions
  FOR EACH ROW
  EXECUTE FUNCTION update_campaign_from_contribution();

-- Migration 7: Add updated_at trigger
-- ============================================
CREATE OR REPLACE FUNCTION update_contributions_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_update_contributions_updated_at ON contributions;
CREATE TRIGGER trigger_update_contributions_updated_at
  BEFORE UPDATE ON contributions
  FOR EACH ROW
  EXECUTE FUNCTION update_contributions_updated_at();

-- Migration 8: Add constraint to prevent negative amounts
-- ============================================
ALTER TABLE contributions 
DROP CONSTRAINT IF EXISTS contributions_amount_check;

ALTER TABLE contributions 
ADD CONSTRAINT contributions_amount_check 
CHECK (amount > 0 AND amount <= 500000);

-- Migration 9: Add constraint for valid payment methods
-- ============================================
ALTER TABLE contributions 
DROP CONSTRAINT IF EXISTS contributions_payment_method_check;

ALTER TABLE contributions 
ADD CONSTRAINT contributions_payment_method_check 
CHECK (payment_method IN ('mpesa', 'cash', 'bank_transfer'));

-- Migration 10: Add constraint for valid statuses
-- ============================================
ALTER TABLE contributions 
DROP CONSTRAINT IF EXISTS contributions_status_check;

ALTER TABLE contributions 
ADD CONSTRAINT contributions_status_check 
CHECK (status IN ('pending', 'verified', 'failed', 'cancelled'));

-- ============================================
-- VERIFICATION QUERIES
-- Run these to verify migrations succeeded
-- ============================================

-- Check if new columns exist
SELECT column_name, data_type 
FROM information_schema.columns 
WHERE table_name = 'contributions' 
AND column_name IN ('idempotency_key', 'user_id', 'transaction_id', 'trans_time');

-- Check if indexes exist
SELECT indexname 
FROM pg_indexes 
WHERE tablename = 'contributions'
AND indexname LIKE 'idx_contributions%';

-- Check if idempotency_keys table exists
SELECT EXISTS (
  SELECT FROM information_schema.tables 
  WHERE table_name = 'idempotency_keys'
);

-- Check if triggers exist
SELECT trigger_name 
FROM information_schema.triggers 
WHERE event_object_table = 'contributions';

-- Check constraints
SELECT constraint_name, constraint_type 
FROM information_schema.table_constraints 
WHERE table_name = 'contributions';

-- ============================================
-- ROLLBACK SCRIPTS (if needed)
-- ============================================

-- To rollback, run these in reverse order:

-- DROP CONSTRAINT contributions_status_check;
-- DROP CONSTRAINT contributions_payment_method_check;
-- DROP CONSTRAINT contributions_amount_check;
-- DROP TRIGGER IF EXISTS trigger_update_contributions_updated_at ON contributions;
-- DROP TRIGGER IF EXISTS trigger_update_campaign_from_contribution ON contributions;
-- DROP FUNCTION IF EXISTS update_contributions_updated_at();
-- DROP FUNCTION IF EXISTS update_campaign_from_contribution();
-- DROP POLICY IF EXISTS "admin_full_access" ON contributions;
-- DROP POLICY IF EXISTS "users_view_own" ON contributions;
-- DROP POLICY IF EXISTS "allow_public_insert" ON contributions;
-- DROP TABLE IF EXISTS idempotency_keys;
-- DROP INDEX IF EXISTS idx_contributions_status_method;
-- DROP INDEX IF EXISTS idx_contributions_campaign_date;
-- DROP INDEX IF EXISTS idx_contributions_phone;
-- DROP INDEX IF EXISTS idx_contributions_mpesa_ref;
-- DROP INDEX IF EXISTS idx_contributions_idempotency;
-- ALTER TABLE contributions DROP COLUMN IF EXISTS trans_time;
-- ALTER TABLE contributions DROP COLUMN IF EXISTS transaction_id;
-- ALTER TABLE contributions DROP COLUMN IF EXISTS user_id;
-- ALTER TABLE contributions DROP COLUMN IF EXISTS idempotency_key;

-- ============================================
-- CLEANUP OLD DATA (Optional - BE CAREFUL!)
-- ============================================

-- Delete old failed transactions (older than 30 days)
-- UNCOMMENT ONLY IF YOU'RE SURE:
-- DELETE FROM contributions 
-- WHERE status = 'failed' 
-- AND created_at < NOW() - INTERVAL '30 days';

-- Delete duplicate pending transactions (keeps most recent)
-- UNCOMMENT ONLY IF YOU'RE SURE:
-- WITH duplicates AS (
--   SELECT 
--     id,
--     ROW_NUMBER() OVER (
--       PARTITION BY contributor_phone, amount, campaign_id, payment_method
--       ORDER BY created_at DESC
--     ) as rn
--   FROM contributions
--   WHERE status = 'pending'
--   AND payment_method = 'mpesa'
--   AND created_at < NOW() - INTERVAL '1 hour'
-- )
-- DELETE FROM contributions
-- WHERE id IN (SELECT id FROM duplicates WHERE rn > 1);

-- ============================================
-- POST-MIGRATION CHECKS
-- ============================================

-- Count contributions by status
SELECT status, COUNT(*) 
FROM contributions 
GROUP BY status 
ORDER BY COUNT(*) DESC;

-- Count by payment method
SELECT payment_method, COUNT(*) 
FROM contributions 
GROUP BY payment_method 
ORDER BY COUNT(*) DESC;

-- Find potential duplicates (for manual review)
SELECT 
  contributor_phone,
  amount,
  campaign_id,
  payment_method,
  COUNT(*) as count,
  array_agg(id ORDER BY created_at) as ids,
  array_agg(status ORDER BY created_at) as statuses,
  array_agg(created_at ORDER BY created_at) as timestamps
FROM contributions
WHERE created_at > NOW() - INTERVAL '7 days'
GROUP BY contributor_phone, amount, campaign_id, payment_method
HAVING COUNT(*) > 1
ORDER BY COUNT(*) DESC;

-- Check for old pending transactions
SELECT 
  id,
  contributor_name,
  amount,
  payment_method,
  status,
  mpesa_ref,
  created_at,
  AGE(NOW(), created_at) as age
FROM contributions
WHERE status = 'pending'
AND created_at < NOW() - INTERVAL '10 minutes'
ORDER BY created_at;

-- ============================================
-- MIGRATION COMPLETE
-- ============================================

SELECT 'All migrations completed successfully!' as status;